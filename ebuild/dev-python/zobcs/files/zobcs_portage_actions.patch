2014-10-01  Magnus Granberg  <zorry@gentoo.org>

	We copy action.py from portage and patch it.
	Use the patched Scheduler and add build_dict so it can be uset.
	We use or own mydepgraph (build_mydepgraph) that call backtrack_depgraph.
	And pass unresolvable in action_depclean so we can use it later.

--- a/zobcs/pym/actions.py	2013-03-22 17:57:23.000000000 +0100
+++ b/zobcs/pym/actions.py	2013-03-22 19:00:43.265582143 +0100
@@ -72,7 +72,7 @@ from _emerge.MetadataRegen import Metada
 from _emerge.Package import Package
 from _emerge.ProgressHandler import ProgressHandler
 from _emerge.RootConfig import RootConfig
-from _emerge.Scheduler import Scheduler
+from zobcs.Scheduler import Scheduler
 from _emerge.search import search
 from _emerge.SetArg import SetArg
 from _emerge.show_invalid_depstring_notice import show_invalid_depstring_notice
@@ -83,6 +83,8 @@ from _emerge.UnmergeDepPriority import U
 from _emerge.UseFlagDisplay import pkg_use_display
 from _emerge.userquery import userquery
 
+from zobcs.build_depgraph import build_mydepgraph
+
 if sys.hexversion >= 0x3000000:
 	long = int
 	_unicode = str
@@ -90,7 +92,7 @@ else:
 	_unicode = unicode
 
 def action_build(settings, trees, mtimedb,
-	myopts, myaction, myfiles, spinner):
+	myopts, myaction, myfiles, spinner, build_dict, session):
 
 	if '--usepkgonly' not in myopts:
 		old_tree_timestamp_warn(settings['PORTDIR'], settings)
@@ -312,16 +314,10 @@ def action_build(settings, trees, mtimed
 			print(darkgreen("emerge: It seems we have nothing to resume..."))
 			return os.EX_OK
 
-		try:
-			success, mydepgraph, favorites = backtrack_depgraph(
-				settings, trees, myopts, myparams, myaction, myfiles, spinner)
-		except portage.exception.PackageSetNotFound as e:
-			root_config = trees[settings['EROOT']]['root_config']
-			display_missing_pkg_set(root_config, e.value)
-			return 1
+		success, settings, trees, mtimedb, mydepgraph = build_mydepgraph(settings,
+			trees, mtimedb, myopts, myparams, myaction, myfiles, spinner, build_dict, session)
 
 		if not success:
-			mydepgraph.display_problems()
 			return 1
 
 	mergecount = None
@@ -613,7 +609,7 @@ def action_depclean(settings, trees, ldp
 	# The calculation is done in a separate function so that depgraph
 	# references go out of scope and the corresponding memory
 	# is freed before we call unmerge().
-	rval, cleanlist, ordered, req_pkg_count = \
+	rval, cleanlist, ordered, req_pkg_count, unresolvable = \
 		calc_depclean(settings, trees, ldpath_mtimes,
 			myopts, action, args_set, spinner)
 
@@ -816,7 +812,7 @@ def calc_depclean(settings, trees, ldpat
 	resolver.display_problems()
 
 	if not success:
-		return 1, [], False, 0
+		return 1, [], False, 0, []
 
 	def unresolved_deps():
 
@@ -827,7 +823,7 @@ def calc_depclean(settings, trees, ldpat
 				unresolvable.add((dep.atom, dep.parent.cpv))
 
 		if not unresolvable:
-			return False
+			return None
 
 		if unresolvable and not allow_missing_deps:
 
@@ -877,11 +873,12 @@ def calc_depclean(settings, trees, ldpat
 					"dependencies then use %s." % good("--nodeps"))
 			writemsg_level("".join("%s%s\n" % (prefix, line) for line in msg),
 				level=logging.ERROR, noiselevel=-1)
-			return True
-		return False
+			return unresolvable
+		return None
 
-	if unresolved_deps():
-		return 1, [], False, 0
+	unresolvable = unresolved_deps():
+	if not unresolvable is None:
+		return 1, [], False, 0, unresolvable
 
 	graph = resolver._dynamic_config.digraph.copy()
 	required_pkgs_total = 0
@@ -1160,7 +1157,7 @@ def calc_depclean(settings, trees, ldpat
 						priority=UnmergeDepPriority(runtime=True),
 						root=pkg.root)):
 						resolver.display_problems()
-						return 1, [], False, 0
+						return 1, [], False, 0, []
 
 			writemsg_level("\nCalculating dependencies  ")
 			success = resolver._complete_graph(
@@ -1168,9 +1165,10 @@ def calc_depclean(settings, trees, ldpat
 			writemsg_level("\b\b... done!\n")
 			resolver.display_problems()
 			if not success:
-				return 1, [], False, 0
-			if unresolved_deps():
-				return 1, [], False, 0
+				return 1, [], False, 0, []
+			unresolvable = unresolved_deps()
+			if not unresolvable is None:
+				return 1, [], False, 0, unresolvable
 
 			graph = resolver._dynamic_config.digraph.copy()
 			required_pkgs_total = 0
@@ -1179,7 +1177,7 @@ def calc_depclean(settings, trees, ldpat
 					required_pkgs_total += 1
 			cleanlist = create_cleanlist()
 			if not cleanlist:
-				return 0, [], False, required_pkgs_total
+				return 0, [], False, required_pkgs_total, []
 			clean_set = set(cleanlist)
 
 	if clean_set:
@@ -1289,8 +1287,8 @@ def calc_depclean(settings, trees, ldpat
 					graph.remove(node)
 					cleanlist.append(node.cpv)
 
-		return 0, cleanlist, ordered, required_pkgs_total
-	return 0, [], False, required_pkgs_total
+		return 0, cleanlist, ordered, required_pkgs_total, []
+	return 0, [], False, required_pkgs_total, []
 
 def action_deselect(settings, trees, opts, atoms):
 	enter_invalid = '--ask-enter-invalid' in opts
@@ -3607,7 +3607,7 @@ def repo_name_duplicate_check(trees):
 
 	return bool(ignored_repos)
 
-def run_action(emerge_config):
+def run_action(emerge_config, build_dict, session):
 
 	# skip global updates prior to sync, since it's called after sync
 	if emerge_config.action not in ('help', 'info', 'sync', 'version') and \
@@ -4059,7 +4059,7 @@ def run_action(emerge_config):
 		retval = action_build(emerge_config.target_config.settings,
 			emerge_config.trees, emerge_config.target_config.mtimedb,
 			emerge_config.opts, emerge_config.action,
-			emerge_config.args, spinner)
+			emerge_config.args, spinner, build_dict, session)
 		post_emerge(emerge_config.action, emerge_config.opts,
 			emerge_config.args, emerge_config.target_config.root,
 			emerge_config.trees, emerge_config.target_config.mtimedb, retval)
